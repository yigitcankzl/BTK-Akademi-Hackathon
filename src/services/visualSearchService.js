import { getGeminiService } from './geminiAPI';
import productService from './ecommerce/productService';
import { getErrorMessage } from '../utils/helpers';

class VisualSearchService {
  constructor() {
    this.geminiService = getGeminiService();
  }

  // G√∂rsel analiz sonu√ßlarƒ±na g√∂re uyumlu √ºr√ºnler √∂ner
  async getMatchingProducts(analysisResult, apiKey, options = {}) {
    try {
      const {
        maxRecommendations = 6,
        includeComplementary = true,
        priceRange = 'all'
      } = options;

      console.log('üîç Getting matching products for visual analysis:', analysisResult);

      // Mevcut √ºr√ºnleri al
      let allProducts = [];
      try {
        const result = await productService.getProducts({ limit: 100 });
        allProducts = result.products;
      } catch (error) {
        const { getAllProducts } = await import('../data/products');
        allProducts = getAllProducts();
      }

      if (!apiKey) {
        // API key yoksa basit algoritma kullan
        return this.getMatchingProductsWithAlgorithm(analysisResult, allProducts, maxRecommendations);
      }

      // Gemini API ile akƒ±llƒ± e≈üle≈ütirme
      this.geminiService.setApiKey(apiKey);
      return await this.getMatchingProductsWithAI(analysisResult, allProducts, maxRecommendations);

    } catch (error) {
      console.error('Error in visual search matching:', error);
      throw new Error(`G√∂rsel e≈üle≈ütirme hatasƒ±: ${getErrorMessage(error)}`);
    }
  }

  // AI destekli √ºr√ºn e≈üle≈ütirme
  async getMatchingProductsWithAI(analysisResult, allProducts, maxRecommendations) {
    try {
      const prompt = `Sen akƒ±llƒ± bir moda ve stil uzmanƒ±sƒ±n. Kullanƒ±cƒ±nƒ±n y√ºklediƒüi g√∂rsel analizi sonu√ßlarƒ±na g√∂re, mevcut √ºr√ºn kataloƒüundan en uygun ${maxRecommendations} √ºr√ºn√º se√ß.

G√ñRSEL ANALƒ∞Z SONUCU:
${analysisResult}

MEVCUT √úR√úN KATALOƒûU:
${allProducts.map(p => `
- ID: ${p.id}
- ƒ∞sim: ${p.name}
- Kategori: ${p.category}
- Marka: ${p.brand || 'Bilinmiyor'}
- Renk/A√ßƒ±klama: ${p.description}
- Fiyat: ‚Ç∫${p.price}
- Puan: ${p.rating}/5
- Stok: ${p.stock}
`).join('')}

E≈ûLE≈ûTIRME KRƒ∞TERLERƒ∞:
1. üé® RENK UYUMU: G√∂rseldeki renklere uygun veya tamamlayƒ±cƒ± renkler
2. üëî STƒ∞L UYUMU: G√∂rseldeki stil ve kategoriye uygun √ºr√ºnler  
3. üè∑Ô∏è KATEGORƒ∞ UYUMU: Aynƒ± veya tamamlayƒ±cƒ± kategorilerden se√ßim
4. üí∞ Fƒ∞YAT UYUMU: Benzer fiyat segmentinden tercih
5. ‚≠ê KALƒ∞TE: Y√ºksek puanlƒ± √ºr√ºnleri √∂ncelik ver
6. üì¶ STOK: Stokta olan √ºr√ºnleri se√ß

√ñZEL TALEPLER:
- Eƒüer g√∂rsel bir g√∂mlek ise ‚Üí pantolon, ayakkabƒ±, aksesuar √∂ner
- Eƒüer g√∂rsel bir elbise ise ‚Üí ayakkabƒ±, √ßanta, takƒ± √∂ner  
- Eƒüer g√∂rsel bir ayakkabƒ± ise ‚Üí uyumlu kƒ±yafetler √∂ner
- Renk uyumunu √ßok √∂nemse (tamamlayƒ±cƒ± renkler dahil)
- Stil b√ºt√ºnl√ºƒü√ºn√º koru

YANIT FORMATI:
Sadece se√ßilen √ºr√ºn ID'lerini JSON array olarak ver. ID'ler string veya sayƒ±sal olabilir:
["1", "2", "3"] veya [1, 2, 3] formatƒ±nda

√ñNEMLƒ∞: ID'ler yukarƒ±daki listeden birebir alƒ±nmalƒ±
Ba≈üka a√ßƒ±klama ekleme, sadece JSON array d√∂nd√ºr.`;

      const response = await this.geminiService.generateContent(prompt, {
        temperature: 0.7,
        maxOutputTokens: 500
      });

      console.log('ü§ñ AI Visual Matching response:', response.text);
      console.log('ü§ñ AI Response length:', response.text.length);
      console.log('ü§ñ AI Response first 100 chars:', response.text.substring(0, 100));

      // JSON parse et - daha tolerant parsing
      let cleanText = response.text.trim().replace(/```json|```/g, '');
      
      // Extract JSON array from response text - handle both string and numeric IDs
      const jsonMatch = cleanText.match(/\[([\s\S]*?)\]/);
      if (jsonMatch) {
        cleanText = jsonMatch[0];
      }
      
      let productIds;
      try {
        productIds = JSON.parse(cleanText);
      } catch (parseError) {
        // Fallback: extract both numbers and strings manually
        console.log('JSON parse failed, extracting IDs manually from:', cleanText);
        
        // Try to extract quoted strings first (for Firebase document IDs)
        const stringMatches = cleanText.match(/"([^"]+)"/g);
        if (stringMatches && stringMatches.length > 0) {
          productIds = stringMatches.map(s => s.replace(/"/g, ''));
          console.log('Extracted string IDs:', productIds);
        } else {
          // Fallback to numeric extraction
          const numbers = cleanText.match(/\d+/g);
          productIds = numbers ? numbers.map(n => parseInt(n)) : [];
          console.log('Extracted numeric IDs:', productIds);
        }
      }

      // √úr√ºn ID'lerini ger√ßek √ºr√ºnlerle e≈üle≈ütir - handle both string and numeric IDs
      const matchedProducts = productIds
        .map(id => {
          // Try exact match first
          let product = allProducts.find(p => p.id === id);
          // If not found and id is string, try converting to number
          if (!product && typeof id === 'string' && !isNaN(id)) {
            product = allProducts.find(p => p.id === parseInt(id));
          }
          // If not found and id is number, try converting to string
          if (!product && typeof id === 'number') {
            product = allProducts.find(p => p.id === id.toString());
          }
          return product;
        })
        .filter(Boolean)
        .slice(0, maxRecommendations);

      console.log('‚úÖ AI Visual Matching products:', matchedProducts.length);
      
      // If AI matching failed to find sufficient products, use algorithm fallback
      if (matchedProducts.length < maxRecommendations * 0.5) {
        console.log('‚ö†Ô∏è AI matching found insufficient products, using algorithm fallback');
        return this.getMatchingProductsWithAlgorithm(analysisResult, allProducts, maxRecommendations);
      }

      return {
        products: matchedProducts,
        matchingMethod: 'ai',
        confidence: matchedProducts.length >= maxRecommendations * 0.8 ? 'high' : 'medium'
      };

    } catch (error) {
      console.warn('AI visual matching failed, using algorithm fallback:', error);
      console.log('AI Response that failed to parse:', error.response || error.message);
      return this.getMatchingProductsWithAlgorithm(analysisResult, allProducts, maxRecommendations);
    }
  }

  // Algoritma tabanlƒ± √ºr√ºn e≈üle≈ütirme
  getMatchingProductsWithAlgorithm(analysisResult, allProducts, maxRecommendations) {
    console.log('üîß Using algorithm-based visual matching');

    try {
      // Analiz sonucundan anahtar kelimeleri √ßƒ±kar
      const keywords = this.extractKeywords(analysisResult);
      const colors = this.extractColors(analysisResult);
      const categories = this.extractCategories(analysisResult);

      console.log('Extracted:', { keywords, colors, categories });

      // √úr√ºnleri skorla
      const scoredProducts = allProducts
        .filter(p => p.stock > 0) // Stokta olanlar
        .map(product => {
          let score = 0;
          let matchReasons = [];

          // Kategori e≈üle≈ümesi - daha esnek
          categories.forEach(category => {
            const categoryLower = category.toLowerCase();
            const productName = product.name?.toLowerCase() || '';
            const productCategory = product.category?.toLowerCase() || '';
            const productDesc = product.description?.toLowerCase() || '';
            
            if (productCategory.includes(categoryLower) || 
                productName.includes(categoryLower) ||
                productDesc.includes(categoryLower)) {
              score += 30;
              matchReasons.push(`Kategori: ${category}`);
            }
          });

          // Renk e≈üle≈ümesi - daha kapsamlƒ±
          colors.forEach(color => {
            const colorLower = color.toLowerCase();
            const productName = product.name?.toLowerCase() || '';
            const productDesc = product.description?.toLowerCase() || '';
            
            if (productName.includes(colorLower) || productDesc.includes(colorLower)) {
              score += 25;
              matchReasons.push(`Renk: ${color}`);
            }
          });

          // Anahtar kelime e≈üle≈ümesi
          keywords.forEach(keyword => {
            const keywordLower = keyword.toLowerCase();
            const productName = product.name?.toLowerCase() || '';
            const productDesc = product.description?.toLowerCase() || '';
            
            if (productName.includes(keywordLower) || productDesc.includes(keywordLower)) {
              score += 15;
              matchReasons.push(`Keyword: ${keyword}`);
            }
          });

          // Giyim kategorisi bonusu (eƒüer g√∂rsel giyim analizi ise)
          const clothingKeywords = ['shirt', 'g√∂mlek', 'dress', 'elbise', 'pants', 'pantolon', 'jacket', 'ceket'];
          const hasClothingKeyword = clothingKeywords.some(kw => 
            analysisResult.toLowerCase().includes(kw)
          );
          
          if (hasClothingKeyword && (product.category?.toLowerCase().includes('giyim') || 
                                     product.category?.toLowerCase().includes('moda') ||
                                     product.category?.toLowerCase().includes('clothing'))) {
            score += 20;
            matchReasons.push('Giyim kategorisi');
          }

          // Kalite bonusu
          score += (product.rating || 0) * 5;

          // Stok bonusu
          if (product.stock > 10) score += 5;

          // Eƒüer hi√ß e≈üle≈üme yoksa rastgele bir skor ver (0-20 arasƒ±)
          if (score === 0) {
            score = Math.random() * 20;
            matchReasons.push('Genel √∂neri');
          }

          return { 
            ...product, 
            matchScore: score,
            matchReasons: matchReasons
          };
        })
        .sort((a, b) => b.matchScore - a.matchScore);

      // En iyi e≈üle≈üenleri al, ama en az 3 √ºr√ºn garantisi
      let selectedProducts = scoredProducts.slice(0, maxRecommendations);
      
      // Eƒüer yeterli √ºr√ºn yoksa, pop√ºler √ºr√ºnlerle tamamla
      if (selectedProducts.length < 3) {
        const additionalProducts = allProducts
          .filter(p => p.stock > 0 && !selectedProducts.some(s => s.id === p.id))
          .sort((a, b) => (b.rating || 0) - (a.rating || 0))
          .slice(0, maxRecommendations - selectedProducts.length);
        
        selectedProducts = [...selectedProducts, ...additionalProducts];
      }

      console.log('Algorithm matching results:', selectedProducts.map(p => ({
        name: p.name,
        score: p.matchScore,
        reasons: p.matchReasons
      })));

      return {
        products: selectedProducts,
        matchingMethod: 'algorithm',
        confidence: selectedProducts.length >= maxRecommendations * 0.7 ? 'medium' : 'low'
      };

    } catch (error) {
      console.error('Algorithm matching failed:', error);
      // En son √ßare: pop√ºler √ºr√ºnler
      const fallbackProducts = allProducts
        .filter(p => p.stock > 0)
        .sort((a, b) => (b.rating || 0) - (a.rating || 0))
        .slice(0, maxRecommendations);

      return {
        products: fallbackProducts,
        matchingMethod: 'fallback',
        confidence: 'low'
      };
    }
  }

  // Analiz sonucundan anahtar kelimeleri √ßƒ±kar
  extractKeywords(analysisResult) {
    const text = analysisResult.toLowerCase();
    const keywords = [];

    // Giyim t√ºrleri
    const clothingTypes = ['shirt', 'g√∂mlek', 'tshirt', 'ti≈ü√∂rt', 'dress', 'elbise', 'pants', 'pantolon', 'jeans', 'jacket', 'ceket', 'sweater', 'kazak', 'hoodie', 'sweatshirt'];
    clothingTypes.forEach(type => {
      if (text.includes(type)) keywords.push(type);
    });

    // Stiller
    const styles = ['casual', 'g√ºnl√ºk', 'formal', 'resmi', 'elegant', '≈üƒ±k', 'sporty', 'spor', 'vintage', 'modern', 'relaxed', 'fitted', 'slim'];
    styles.forEach(style => {
      if (text.includes(style)) keywords.push(style);
    });

    // Malzemeler
    const materials = ['cotton', 'pamuk', 'linen', 'keten', 'denim', 'kot', 'silk', 'ipek', 'wool', 'y√ºn', 'polyester'];
    materials.forEach(material => {
      if (text.includes(material)) keywords.push(material);
    });

    return [...new Set(keywords)]; // Tekrarlarƒ± kaldƒ±r
  }

  // Analiz sonucundan renkleri √ßƒ±kar
  extractColors(analysisResult) {
    const text = analysisResult.toLowerCase();
    const colors = [];

    const colorMap = {
      'beige': ['beige', 'bej', 'krem', 'cream'],
      'white': ['white', 'beyaz', 'off-white'],
      'black': ['black', 'siyah'],
      'blue': ['blue', 'mavi', 'navy', 'lacivert'],
      'red': ['red', 'kƒ±rmƒ±zƒ±'],
      'green': ['green', 'ye≈üil'],
      'brown': ['brown', 'kahverengi', 'tan'],
      'gray': ['gray', 'grey', 'gri'],
      'pink': ['pink', 'pembe'],
      'yellow': ['yellow', 'sarƒ±']
    };

    Object.entries(colorMap).forEach(([color, variations]) => {
      variations.forEach(variation => {
        if (text.includes(variation)) {
          colors.push(color);
        }
      });
    });

    return [...new Set(colors)]; // Tekrarlarƒ± kaldƒ±r
  }

  // Analiz sonucundan kategorileri √ßƒ±kar
  extractCategories(analysisResult) {
    const text = analysisResult.toLowerCase();
    const categories = [];

    const categoryMap = {
      'G√∂mlek': ['shirt', 'g√∂mlek', 'button-down', 'collar'],
      'T-shirt': ['t-shirt', 'tshirt', 'ti≈ü√∂rt'],
      'Pantolon': ['pants', 'pantolon', 'trousers', 'jeans'],
      'Elbise': ['dress', 'elbise'],
      'Ceket': ['jacket', 'ceket', 'blazer'],
      'Ayakkabƒ±': ['shoe', 'ayakkabƒ±', 'sneaker', 'boot'],
      'Aksesuar': ['accessory', 'aksesuar', 'bag', '√ßanta', 'watch', 'saat']
    };

    Object.entries(categoryMap).forEach(([category, keywords]) => {
      keywords.forEach(keyword => {
        if (text.includes(keyword)) {
          categories.push(category);
        }
      });
    });

    return [...new Set(categories)]; // Tekrarlarƒ± kaldƒ±r
  }

  // Tamamlayƒ±cƒ± √ºr√ºn kategorilerini belirle
  getComplementaryCategories(mainCategory) {
    const complementaryMap = {
      'G√∂mlek': ['Pantolon', 'Ayakkabƒ±', 'Aksesuar', 'Ceket'],
      'T-shirt': ['Pantolon', 'Ayakkabƒ±', 'Ceket', 'Aksesuar'],
      'Pantolon': ['G√∂mlek', 'T-shirt', 'Ayakkabƒ±', 'Ceket'],
      'Elbise': ['Ayakkabƒ±', 'Aksesuar', 'Ceket'],
      'Ayakkabƒ±': ['Pantolon', 'G√∂mlek', 'T-shirt', 'Elbise'],
      'Ceket': ['G√∂mlek', 'T-shirt', 'Pantolon']
    };

    return complementaryMap[mainCategory] || [];
  }
}

// Singleton instance
let visualSearchInstance = null;

export function getVisualSearchService() {
  if (!visualSearchInstance) {
    visualSearchInstance = new VisualSearchService();
  }
  return visualSearchInstance;
}

export default VisualSearchService;